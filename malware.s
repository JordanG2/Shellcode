section .data
    file db 'test_elf', 0    
    buffer db 64
        
    message_elf db "Il s agit d'un fichier ELF",10,0
    length_elf equ $-message_elf
    
    message_not_elf db "Ce n'est pas un fichier elf",10,0
    length_not_elf equ $-message_not_elf
    
    error_msg db "Erreur de lecture", 10, 0
    length_error equ $-error_msg
    
    message_found_ptnote db "C'est ici qu'on va injecter du code", 10, 0
    length_found_ptnote equ $-message_found_ptnote
    
    message_no_ptnote db "Segment PT_NOTE non trouvé", 10, 0
    length_no_ptnote equ $-message_no_ptnote

    message_segments_looked db "On parcours les segments pour retrouver PT_Note ", 10, 0
    length_segments_looked equ $-message_segments_looked

    print_value_buffer db '00000000', 10, 0   ; Buffer pour afficher les valeurs
    length_print_value equ $-print_value_buffer

section .text
    global _start

_start:
    ; Ouvrir le fichier
    mov rax, 2               ; Appel système open
    mov rdi, file            ; Nom du fichier
    mov rsi, 0               ; Mode lecture seule
    mov rdx, 0               ; Pas de flag
    syscall                  ; Exécuter open
    test rax, rax
    js error_exit
    mov rdi, rax             ; Stocker le descripteur de fichier dans rdi

read_firstByte:
    ; Lire les premiers octets pour vérifier s'il s'agit d'un fichier ELF
    mov rax, 0               ; Appel système read
    mov rsi, buffer          ; Stocker les données lues dans le buffer
    mov rdx, 64              ; Lire 64 octets
    syscall                  ; Exécuter read
    test rax, rax
    js error_exit

    ; Vérifier si c'est un fichier ELF
    cmp dword [buffer], 0x464C457F   ; Comparer avec le magic number ELF
    je ELF_file

not_ELF_file:
    ; Gérer les fichiers non ELF
    mov rax, 1
    mov rdi, 1
    mov rsi, message_not_elf
    mov rdx, length_not_elf
    syscall
    jmp end

ELF_file:
    ; Afficher un message pour un fichier ELF
    mov rax, 1
    mov rdi, 1
    mov rsi, message_elf
    mov rdx, length_elf
    syscall
    
    ; Passer à l'analyse de la table des segments
    jmp Parse
          
Parse:
    ;mov rsi, buffer                ; Pointeur vers le buffer ELF

    ; Récupérer les informations nécessaires de l'en-tête ELF
    mov r8, qword [buffer + 32]   ; Offset des Program Headers
    mov r9d, dword [buffer + 54]  ; Taille d'une entrée Program Header
    mov r10d, dword [buffer + 56] ; Nombre d'entrées Program Header

    ; Message pour indiquer que l'on recherche PT_note
    mov rax, 1
    mov rdi, 1
    mov rsi, message_segments_looked
    mov rdx, length_segments_looked
    syscall

    ; Initialiser les variables pour la recherche
    mov rsi, rax                  ; Déplacer l'offset de la table dans rsi
    xor r8, r8                    ; Initialiser l'indice des segments

check_program_headers:
    test r10d, r10d               ; Vérifier si nous avons encore des entrées à traiter
    jz limit_reached              ; Si terminé, sortir

    ; Se positionner à l'entrée actuelle dans la table des Program Headers
    mov rax, 8                    ; syscall: lseek
    mov rdi, rdi                  ; Descripteur de fichier
    mov rsi, r8                   ; Offset du Program Header actuel
    mov rdx, 0                    ; SEEK_SET
    syscall
    test rax, rax
    js error_exit

    ; Lire l'entrée actuelle de la table
    mov rax, 0                    ; syscall: read
    mov rsi, buffer               ; Réutiliser le buffer
    mov rdx, r9                  ; Taille d'une entrée
    syscall
    test rax, rax
    js error_exit

    ; Vérifier si l'entrée est de type PT_NOTE
    mov eax, dword [buffer]       ; Charger p_type
    cmp eax, 4                    ; PT_NOTE = 4
    je found_pt_note

    ; Passer à l'entrée suivante
    add r8, r9                    ; Avancer au prochain Program Header
    dec r10d                      ; Décrémenter le compteur
    jmp check_program_headers     ; Revenir à la vérification du prochain segment

found_pt_note:
    ; Si un segment PT_NOTE est trouvé, afficher un message
    mov rax, 1
    mov rdi, 1
    mov rsi, message_found_ptnote
    mov rdx, length_found_ptnote
    syscall

    ; Passer à la suite
    jmp end

limit_reached:
    ; Si on a parcouru tous les segments et qu'on n'a pas trouvé PT_NOTE
    mov rax, 1
    mov rdi, 1
    mov rsi, message_no_ptnote
    mov rdx, length_no_ptnote
    syscall

    jmp end

error_exit:
    ; Afficher un message d'erreur
    mov rax, 1
    mov rdi, 1
    mov rsi, error_msg
    mov rdx, length_error
    syscall

end:
    ; Sortir du programme
    mov rax, 60 
    xor rdi, rdi                
    syscall

print_value:
    push rax               ; Sauvegarder EAX
    push rbx               ; Sauvegarder EBX (diviseur 10)
    push rsi               ; Sauvegarder RSI

    mov rsi, print_value_buffer  ; Pointeur vers le buffer
    add rsi, 7             ; Place le pointeur à la fin (dernière position avant '\n')
    mov rcx, 8             ; 8 chiffres à traiter

convert_loop:
    xor rdx, rdx           ; Efface RDX (reste de la division)
    mov rbx, 10            ; Diviseur (valeur 10)
    div rbx                ; Divise EAX par 10 (division unsigned)
    add dl, '0'            ; Convertit le chiffre en ASCII
    mov [rsi], dl          ; Stocke le caractère ASCII dans le buffer
    dec rsi                ; Décrémente le pointeur
    loop convert_loop      ; Répète pour les 8 chiffres

    ; Afficher le buffer
    mov rax, 1             ; Appel système write
    mov rdi, 1             ; Sortie standard (stdout)
    mov rsi, print_value_buffer  ; Buffer à écrire
    mov rdx, length_print_value  ; Taille de la chaîne
    syscall

    pop rsi                ; Restaurer RSI
    pop rbx                ; Restaurer EBX
    pop rax                ; Restaurer EAX
    ret
